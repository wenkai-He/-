<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>

    1.js垃圾回收机制主要分为两种 1.引用计数(少用)2.标记清除(主流);
    引用计数:当声明了一个变量并且将一个引用类型赋值给该变量的时候这个值的引用次数就为 1
    如果同一个对象又被赋给另一个变量，那么引用数加 1
    如果该变量的值被其他的值覆盖了，则引用次数减 1
    当这个值的引用次数变为 0 的时候，说明没有变量在使用，这个值没法被访问了，回收空间，垃圾回收器会在运行的时候清理掉引用次数为 0 的值占用的内存

    缺点:循环引用处理不了 需要设置计数器 占空间 因为我们不知道引用的上限
    优点:可以立即回收 不用像标记清除进行循环


    标记清除:当变量进行执行环境时 就被标记为进入 当变量离开环境就标记为离开 下一轮垃圾回收就会将它回收掉
    优点:实现的较简单 只需要标记0 1
    缺点:清除之后 对象的内存空间是不变的 这样会造成空闲内存是不连续的 出现内存碎片 需要单向遍历找出合适的空位塞入新建对象
    如何分配?主要采用first-fit算法 就是只要从前往后遍历找到第一个符合的就塞入 
    标记整理:标记结束后,标记整理算法会将活着的对象向尾部移动,最后清理边界内存即可。


    V8最新垃圾回收机制:
    之前说到现在主流的清除方法是标记清除  然而这样每次都需要遍历所有对象 一些大、持久的对象 跟一些小、快速清除的对象都要一起遍历 影响效率。
    所以就诞生了新的机制:分代式回收机制。
    新生代就是新产生的对象 老生代就是存活时间较长的对象。
    新生代垃圾回收机制:分为使用区和空闲区,新写入的变量就加入使用区，当使用区快满时执行一次垃圾回收
        刚开始是复制一份写入空闲区，进行排序，然后进行清理 并且清理使用区 再进行互换 如果一个对象进行了多次互换 就把他放入老生代
    老生代就跟以前的一样


</body>

</html>